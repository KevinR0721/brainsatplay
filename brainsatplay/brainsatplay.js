var brainsatplay;(()=>{var t={980:t=>{t.exports="/*\n\nData Streams\n- Local hardware\n  -- Serial\n  -- BLE\n  -- Sockets/SSEs\n- Server\n  -- Hardware and Game state data via Websockets\n\nData Processing \n- eegworker.js, eegmath, bcijs, etc.\n\nData State\n- Sort raw/filtered data\n- Sort processed data\n\nUI Templating\n- StateManager.js\n- UIManager.js\n- ObjectListener.js\n- DOMFragment.js\n\nLocal Storage\n- BrowserFS for IndexedDB\n- CSV saving/parsing\n\nFrontend Execution\n- UI State\n- Server State\n- Game/App State(s)\n\n*/\nimport 'regenerator-runtime/runtime' //fixes async calls in this bundler\n\nimport {eeg32, eegmath} from './utils/eeg32'\nimport {Biquad, makeNotchFilter, makeBandpassFilter, DCBlocker} from './utils/signal_analysis/BiquadFilters'\nimport {MuseClient} from 'muse-js'\n\n\nexport class brainsatplay {\n\tconstructor(\n\t\tusername='',\n\t\tpassword='',\n\t\taccess='public',\n\t\tappname='',\n\t\tremoteHostURL='http://localhost:8000',//https://brainsatplay.azurewebsites.net/',\n\t\tlocalHostURL='http://127.0.0.1:8000'\n\t) {\n\t\tthis.devices = [];\n\n\t\tthis.info = {\n\t\t\tnDevices: 0,\n\t\t\tauth:{\n\t\t\t\turl: new URL(remoteHostURL), \n\t\t\t\tusername:username, \n\t\t\t\tpassword:password, \n\t\t\t\taccess:access, \n\t\t\t\tappname:appname,\n\t\t\t\tconsent:{raw:false, brains:false},\n\t\t\t\tauthenticated:false\n\t\t\t},\n\t\t\tsubscribed: false,\n\t\t\tconnections: [],\n\t\t\tlocalHostURL: localHostURL\n\t\t}\n\n\t\tthis.socket = null;\n\t}\n\n\tsetLoginInfo(username='',password='',access='public',appname='') {\n\t\tthis.info.auth.username = username;\n\t\tthis.info.auth.password = password;\n\t\tthis.info.auth.access = access;\n\t\tthis.info.auth.appname = appname;\n\t}\n\n\tconnect(\n\t\tdevice=\"FreeEEG32_2\", //\"FreeEEG32\",\"FreeEEG32_19\",\"muse\"\n\t\tstreaming=false,\n\t\tstreamParams=[['EEG_Ch','FP1','all']], //Device properties to stream\n\t\tuseFilters=true, //Filter device output if it needs filtering (some hardware already applies filters so we may skip those)\n\t\tpipeToAtlas=true\n\t\t) {\n\t\t\tif(streaming === true) {\n\t\t\t\tconsole.log(this.socket)\n\t\t\t\tif(this.socket == null || this.socket.readyState !== 1) {\n\t\t\t\t\tconsole.error('Server connection not found, please run login() first');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.devices.push(\n\t\t\t\tnew deviceStream(device,streaming,useFilters,pipeToAtlas,this.socket,streamParams,this.info.auth)\n\t\t\t);\n\t\t\t\n\t\t\tthis.devices[this.devices.length-1].connect();\n\t\t\tthis.info.nDevices++;\n\t\t}\n\n\t//Server login and socket initialization\n\tasync login(dict=this.info.auth, baseURL=this.info.auth.url.toString()) {\n\t\t//Connect to websocket\n\t\tif (this.socket == null  || this.socket.readyState !== 1){\n\t\t\tthis.socket = this.setupWebSocket(dict);\n\t\t\tthis.info.auth.authenticated = true;\n\t\t\tthis.subscribed=true;\n\t\t\tthis.info.nDevices++;\n\t\t}\n\t} \n\n\tasync signup(dict={}, baseURL=this.info.auth.url.toString()) {\n\t\tbaseURL = this.checkURL(baseURL);\n        let json = JSON.stringify(dict);\n        let response = await fetch(baseURL.toString() + 'signup',\n            {\n                method: 'POST',\n                mode: 'cors',\n                headers: new Headers({\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                }),\n                body: json\n            }).then((res) => {\n            return res.json().then((message) => message);\n        })\n            .then((message) => {\n                console.log(`\\n`+message);\n                return message;\n            })\n            .catch(function (err) {\n                console.error(`\\n`+err.message);\n            });\n\n        return response;\n\t}\n\n\tasync request(body,method=\"POST\",pathname='',baseURL=this.info.auth.url.toString()){\n\t\tif (pathname !== ''){\n            baseURL = this.checkURL(baseURL);\n            pathname = this.checkPathname(pathname);\n            let dict = {\n                method: method,\n                mode: 'cors',\n                headers: {\n                    'Accept': 'application/json',\n                    'Content-Type': 'application/json'\n                },\n            };\n            \n            if (method === 'POST'){\n                dict.body = JSON.stringify(body);\n            }\n\n            return await fetch(baseURL + pathname, dict).then((res) => {\n            return res.json().then((dict) => {                 \n                return dict.message;\n            })\n        })\n            .catch(function (err) {\n                console.error(`\\n`+err.message);\n            });\n        } else {\n            console.error(`You must provide a valid pathname to request resources from ` + baseURL);\n            return;\n        }\n\t}\n\n\tsetupWebSocket(auth=this.info.auth) {\n\n\t\tlet socket = null;\n        let subprotocol = ['username'+auth.username,\n        'password'+auth.password,\n        'appname'+auth.appname];\n\t\tif (auth.url.protocol === 'http:') {\n            socket = new WebSocket(`ws://` + auth.url.host, subprotocol);\n        } else if (auth.url.protocol === 'https:') {\n            socket = new WebSocket(`wss://` + auth.url.host, subprotocol);\n        } else {\n            console.log('invalid protocol')\n            return;\n\t\t}\n\n        socket.onerror = () => {\n            console.log('error')\n        };\n\n        socket.onopen = () => {\n            console.log('ping')\n            socket.send(JSON.stringify({msg:'ping'}))\n        };\n\n        socket.onmessage = (msg) => {\n            let obj = JSON.parse(msg.data);\n            console.log(obj.msg)\n        }\n\n        socket.onclose = (msg) => {\n            console.log('close')\n        }\n\n\t\treturn socket;\n\t}\n\n\tsendWSCommand(command='',dict={}){\n\t\tif(this.socket != null  && this.socket.readyState === 1){\n\t\t\tif(command === 'initializeBrains') {\n\t\t\t\tthis.socket.send(JSON.stringify({'destination':'initializeBrains','public':this.auth.access === 'public'}))\n\t\t\t}\n\t\t\telse if (command === 'bci') {\n\t\t\t\tdict.destination = 'bci';\n\t\t\t\tdict.id = auth.username;\n\t\t\t\tdict.consent = auth.consent;\n\t\t\t\tif(auth.consent.game === true) {\n\t\t\t\t\t//let reserved = ['voltage','time','electrode','consent'];\n\t\t\t\t\t//let me = this.brains[this.info.access].get(this.me.username);\n\t\t\t\t\t//if (me !== undefined){\n\t\t\t\t\t//\tObject.keys(me.data).forEach((key) => {\n\t\t\t\t\t//\t\tif (!reserved.includes(key)){\n\t\t\t\t\t//\t\t\tdict[key] = me.data[key];\n\t\t\t\t\t//\t\t}\n\t\t\t\t\t//\t});\n\t\t\t\t\t//}\n\t\t\t\t}\n\t\t\t\tif(this.info.auth.consent.raw === false) {\n\t\t\t\t\tdict.signal = [];\n\t\t\t\t\tdict.time = [];\n\t\t\t\t}\n\t\t\t\tdict = JSON.stringify(dict);\n\t\t\t\tthis.socket.send(dict);\n\t\t\t} else {\n\t\t\t\tthis.socket.send(JSON.stringify({msg:command}))\n\t\t\t}\n\t\t}\n\t}\n\n\tdisconnect(deviceIdx=this.devices[this.devices.length-1]) {\n\t\tthis.devices[deviceIdx].disconnect();\n\t}\n\n\tcloseSocket() {\n\t\tthis.socket.close();\n\t}\n\n\tgetUsersOld(dict={ //\n\t\tdestination:'initializeBrains',\n\t\tappname:'',\n\t\tmsg:'',\n\t\tnBrains:0,\n\t\tprivateBrains:0,\n\t\tprivateInfo:'',\n\t\tninterfaces:0,\n\t\tids:[],\n\t\tchannelNames:[]\n\t}) {\n\t\tthis.socket.send(JSON.stringify(dict));\n\t}\n\n\tonNewConnectionOld(response){ //If a user is added to the server\n\t\tthis.info.connections.push({\n\t\t\tusername:response.id,\n\t\t\taccess:response.access,\n\t\t\tchannelNames:response.channelNames,\n\t\t\tdestination:response.destination\n\t\t});\n\t\tthis.info.nDevices++;\n\t}\n\n\tonConnectionLost(response){ //If a user is removed from the server\n\t\tlet found = false; let idx = 0;\n\t\tlet c = this.info.connections.find((o,i) => {\n\t\t\tif(o.username === response.username) {\n\t\t\t\tfound = true;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tif (found === true) {\n\t\t\tthis.info.connections.splice(idx,1);\n\t\t\tthis.info.nDevices--;\n\t\t}\n\t}\n\n\tcheckURL(url) {\n        if (url.slice(-1) !== '/') {\n            url += '/';\n        }\n        return url;\n    }\n\n\tcheckPathname(pathname) {\n        if (pathname.slice(0) === '/') {\n            pathname.splice(0,1);\n        }\n        return pathname;\n    }\n\n}\n\n\nclass biquadChannelFilterer {\n    constructor(channel=\"A0\",sps=512, filtering=true, scalingFactor=1) {\n        this.channel=channel; this.idx = 0; this.sps = sps;\n        this.filtering=filtering;\n        this.bplower = 3; this.bpupper = 45;\n\t\tthis.scalingFactor = scalingFactor;\n\n\t\tthis.useSMA4 = false; this.last4=[];\n\t\tthis.useNotch50 = true; this.useNotch60 = true;\n\t\tthis.useLp1 = false; this.useBp1 = false;\n\t\tthis.useDCB = true; this.useScaling = false;\n\n        this.notch50 = [\n                    makeNotchFilter(50,sps,1)\n                ];\n        this.notch60 = [\n                    makeNotchFilter(60,sps,1)\n                ];\n        this.lp1 = [\n                    new Biquad('lowpass', 50, sps),\n                    new Biquad('lowpass', 50, sps),\n                    new Biquad('lowpass', 50, sps),\n                    new Biquad('lowpass', 50, sps)\n                ];\n        this.bp1 = [\n                    makeBandpassFilter(this.bplower,this.bpupper,sps,9.75),\n                    makeBandpassFilter(this.bplower,this.bpupper,sps,9.75),\n                    makeBandpassFilter(this.bplower,this.bpupper,sps,9.75),\n                    makeBandpassFilter(this.bplower,this.bpupper,sps,9.75)\n                ];\n        this.dcb = new DCBlocker(0.995);\n    }\n\n    reset(sps=this.sps) {\n        this.notch50 = makeNotchFilter(50,sps,1);\n        this.notch60 = makeNotchFilter(60,sps,1);\n        this.lp1 = [\n                    new Biquad('lowpass', 50, sps),\n                    new Biquad('lowpass', 50, sps),\n                    new Biquad('lowpass', 50, sps),\n                    new Biquad('lowpass', 50, sps)\n                ];\n\t\tthis.bp1 = [\n\t\t\t\t\tmakeBandpassFilter(this.bplower,this.bpupper,sps,9.75),\n\t\t\t\t\tmakeBandpassFilter(this.bplower,this.bpupper,sps,9.75),\n\t\t\t\t\tmakeBandpassFilter(this.bplower,this.bpupper,sps,9.75),\n\t\t\t\t\tmakeBandpassFilter(this.bplower,this.bpupper,sps,9.75)\n\t\t\t\t];\n        this.dcb = new DCBlocker(0.995);\n    }\n\n    setBandpass(bplower=this.bplower,bpupper=this.bpupper,sps=this.sps) {\n        this.bplower=bplower; this.bpupper = bpupper;\n        this.bp1 = [\n            makeBandpassFilter(bplower,bpupper,sps),\n            makeBandpassFilter(bplower,bpupper,sps),\n            makeBandpassFilter(bplower,bpupper,sps),\n            makeBandpassFilter(bplower,bpupper,sps)\n        ];\n    }\n\n    apply(latestData=0, idx=this.lastidx+1) {\n        let out=latestData; \n        if(this.filtering === true) {\n\t\t\tif(this.useDCB === true) { //Apply a DC blocking filter\n                out = this.dcb.applyFilter(out);\n            }\n            if(this.useSMA4 === true) { // 4 sample simple moving average (i.e. low pass)\n                if(idx < 4) {\n\t\t\t\t\tthis.last4.push(out);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tout = this.last4.reduce((accumulator, currentValue) => accumulator + currentValue)/this.last4.length;\n\t\t\t\t\tthis.last4.shift();\n\t\t\t\t\tthis.last4.push(out);\n\t\t\t\t}\n            }\n            if(this.useNotch50 === true) { //Apply a 50hz notch filter\n                this.notch50.forEach((f,i) => {\n                    out = f.applyFilter(out);\n                });\n            }\n            if(this.useNotch60 === true) { //Apply a 60hz notch filter\n                this.notch60.forEach((f,i) => {\n                    out = f.applyFilter(out);\n                });\n            } \n            if(this.useLp1 === true) { //Apply 4 50Hz lowpass filters\n                this.lp1.forEach((f,i) => {\n                    out = f.applyFilter(out);\n                });\n            }\n            if(this.useBp1 === true) { //Apply 4 Bandpass filters\n                this.bp1.forEach((f,i) => {\n                    out = f.applyFilter(out);\n                });\n\t\t\t\tout *= this.bp1.length;\n            }\n            if(this.useScaling === true){\n                out *= this.scalingFactor;\n            }\n        }\n        this.lastidx=idx;\n        //console.log(this.channel, out)\n        return out;\n    }\n}\n\n\nclass deviceStream {\n\tconstructor(\n\t\tdevice=\"FreeEEG32_2\",\n\t\tstreaming=true,\n\t\tuseFilters=true,\n\t\tpipeToAtlas=true,\n\t\tsocket=null,\n\t\tstreamParams=[],\n\t\tauth={\n\t\t\tusername:'guest', \n\t\t\tconsent:{raw:false, brains:false}\n\t\t}\n\t) {\n\n\t\tthis.deviceName = device;\n\n\t\tthis.device = null; //Device object, can be instance of eeg32, MuseClient, etc.\n\t\tthis.streaming = streaming;\n\t\tthis.streamParams = streamParams; //[['EEG_Ch','FP1','all'],['EEG_FFT','AF7','all']]\n\t\tthis.socket = socket; //Store sockets here for use\n\n\t\tthis.streamTable=[];\n\t\tthis.streamLoopTiming = 100; //ms between update checks\n\n\t\tthis.auth = auth;\n\t\tthis.sps = null;\n\t\tthis.useFilters = useFilters;\n\t\tthis.useAtlas = false;\n\t\tthis.filters = [];\n\t\tthis.eegChannelTags = [];\n\t\tthis.atlas = null;\n\t\tthis.simulating = false;\n\n\t\tthis.init(device,useFilters,pipeToAtlas);\n\t}\n\n\tinit = (device,useFilters,pipeToAtlas) => {\n\t\t\n\t\tif(device.indexOf(\"FreeEEG32\") > -1) {\n\t\t\tthis.sps = 512;\n\t\t\tif(device === \"FreeEEG32_2\") { \n\t\t\t\tthis.eegChannelTags = [\n\t\t\t\t\t{ch: 4, tag: \"FP2\"},\n\t\t\t\t\t{ch: 24, tag: \"FP1\"},\n\t\t\t\t\t{ch: 8, tag: \"other\"}\n\t\t\t\t];\n\t\t\t}\n\t\t\telse if (device === 'FreeEEG32_19') {\n\t\t\t\tthis.eegChannelTags = [\n\t\t\t\t\t{ch: 4, tag: \"FP2\"},\n\t\t\t\t\t{ch: 24, tag: \"FP1\"},\n\t\t\t\t\t{ch: 8, tag: \"other\"}\n\t\t\t\t];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.eegChannelTags = [\n\t\t\t\t\t{ch: 4, tag: \"FP2\"},\n\t\t\t\t\t{ch: 24, tag: \"FP1\"},\n\t\t\t\t\t{ch: 8, tag: \"other\"}\n\t\t\t\t];\n\t\t\t}\n\t\t\tthis.device = new eeg32(\n\t\t\t\t(newLinesInt) => {\n\t\t\t\t\tthis.eegChannelTags.forEach((o,i) => {\n\t\t\t\t\t\tlet latest = this.device.getLatestData(\"A\"+o.ch,newLinesInt);\n\t\t\t\t\t\tlet latestFiltered = new Array(latest.length).fill(0);\n\t\t\t\t\t\tif(o.tag !== \"other\" && this.useFilters === true) { \n\t\t\t\t\t\t\tthis.filters.forEach((f,j) => {\n\t\t\t\t\t\t\t\tif(f.channel === \"A\"+o.ch) {\n\t\t\t\t\t\t\t\t\tlatest.forEach((sample,k) => { \n\t\t\t\t\t\t\t\t\t\tlatestFiltered[k] = f.apply(sample); \n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\tif(this.useAtlas === true) {\n\t\t\t\t\t\t\t\tlet coord;\n\t\t\t\t\t\t\t\tif(o.tag !== null) { coord = this.atlas.getEEGDataByTag(o.tag);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t} else { coord = this.atlas.getEEGDataByChannel(o.ch); }\n\t\t\t\t\t\t\t\tcoord.filtered.push(latestFiltered);\n\t\t\t\t\t\t\t\tcoord.raw.push(latest);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(this.useAtlas === true) {\n\t\t\t\t\t\t\t\tlet coord;\n\t\t\t\t\t\t\t\tif(o.tag !== null) { coord = this.atlas.getEEGDataByTag(o.tag);\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t} else { coord = this.atlas.getEEGDataByChannel(o.ch); }\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcoord.raw.push(latest);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t//this.onMessage(newLinesInt);\n\t\t\t\t},\n\t\t\t\t()=>{\t\n\t\t\t\t},\n\t\t\t\t()=>{\n\t\t\t\t}\n\t\t\t);\n\t\t\tif(useFilters === true) {\n\t\t\t\tthis.eegChannelTags.forEach((row,i) => {\n\t\t\t\t\tif(row.tag !== 'other') {\n\t\t\t\t\t\tthis.filters.push(new biquadChannelFilterer(\"A\"+row.ch,this.sps,true,this.device.uVperStep));\n\t\t\t\t\t}\n\t\t\t\t\telse { \n\t\t\t\t\t\tthis.filters.push(new biquadChannelFilterer(\"A\"+row.ch,this.sps,false,this.device.uVperStep)); \n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t\telse if(device === \"muse\") {\n\t\t\tthis.sps = 256;\n\t\t\tthis.eegChannelTags = [\n\t\t\t\t{ch: 0, tag: \"T9\"},\n\t\t\t\t{ch: 1, tag: \"AF7\"},\n\t\t\t\t{ch: 2, tag: \"AF8\"},\n\t\t\t\t{ch: 3, tag: \"T10\"},\n\t\t\t\t{ch: 4, tag: \"other\"}\n\t\t\t];\n\t\t\tthis.device = new MuseClient();\n\t\t}\n\t\telse if(device === \"cyton\") {\n\n\t\t}\n\t\telse if(device === \"ganglion\") {\n\n\t\t}\n\t\telse if(device === \"hegduino\") {\n\n\t\t}\n\n\n\t\tif(pipeToAtlas === true) {\n\t\t\tlet eegConfig;\n\t\t\tif(device === 'muse') { eegConfig = 'muse'; }\n\t\t\telse if(device.indexOf('FreeEEG32') > -1) {\teegConfig = '10_20'; }\n\t\t\tthis.atlas = new dataAtlas(location+\":\"+device,{eegshared:{eegChannelTags:this.eegChannelTags, sps:this.sps}},eegConfig,true,true,['fft']);\n\t\t\tthis.useAtlas = true;\n\t\t\tthis.configureDefaultStreamTable();\n\t\t} else if (pipeToAtlas !== false) {\n\t\t\tthis.atlas = pipeToAtlas; //External atlas reference\n\t\t\tif(device==='muse') { this.atlas.data.eeg = this.atlas.genMuseAtlas(); }\n\t\t\telse if(device.indexOf('FreeEEG32') > -1) { this.atlas.data.eeg = this.atlas.gen10_20Atlas(); }\n\t\t\t\n\t\t\tthis.useAtlas = true;\n\t\t\tthis.configureDefaultStreamTable();\n\t\t}\n\n\t\tif(this.streaming === true) this.streamLoop();\n\t}\n\n\tasync connect() {\n\t\n\t\tif(this.deviceName === \"FreeEEG32_2\" || this.deviceName === \"FreeEEG32_19\") {\n\t\t\tawait this.device.setupSerialAsync();\n\t\t}\n\t\telse if (this.deviceName === \"muse\") {\n\t\t\t//connect muse and begin streaming\n\t\t\tawait this.device.connect();\n\t\t\tawait this.device.start();\n\t\t\tthis.device.eegReadings.subscribe(reading => {\n\n\t\t\t});\n\t\t\tthis.device.telemetryData.subscribe(telemetry => {\n\n\t\t\t});\n\t\t\tthis.device.accelerometerData.subscribe(accel => {\n\n\t\t\t});\n\t\t}\n\t\telse if (this.deviceName === \"cyton\" || this.deviceName === \"ganglion\") {\n\t\t\t//connect boards and begin streaming (See WIP cyton.js in /js/utils/hardware_compat)\n\t\t}\n\t\tthis.onConnect();\n\t\t\n\t}\n\n\tconfigureDefaultStreamTable(params=[]) {\n\t\t//Stream table default parameter callbacks to extract desired data from the data atlas\n\t\tlet getEEGChData = (channel,nSamples='all') => {\n\t\t\tlet get = nSamples;\n\t\t\tif(this.useAtlas === true) {\n\t\t\t\tlet coord = false;\n\t\t\t\tif(typeof channel === 'number') {\n\t\t\t\t\tcoord = this.atlas.getEEGDataByChannel(channel);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoord = this.atlas.getEEGDataByTag(channel);\n\t\t\t\t}\n\t\t\t\tif(coord !== false) { \n\t\t\t\t\tif(get === 'all') {\n\t\t\t\t\t\tget = coord.count-coord.lastRead;\n\t\t\t\t\t\tcoord.lastRead = coord.count; //tracks count of last reading for keeping up to date\n\t\t\t\t\t\tif(get === 0) return undefined;\n\t\t\t\t\t}\n\t\t\t\t\tif (coord.filtered.length > 0) {\n\t\t\t\t\t\tlet times = coord.times.slice(coord.times.length - get,coord.times.length);\n\t\t\t\t\t\tlet samples = coord.filtered.slice(coord.filtered.length - get,coord.filtered.length);\n\t\t\t\t\t\treturn {times:times, samples:samples};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet getEEGFFTData = (channel,nArrays='all') => {\n\t\t\tlet get = nArrays;\n\t\t\tif(this.useAtlas === true) {\n\t\t\t\tlet coord = false;\n\t\t\t\tif(typeof channel === 'number') {\n\t\t\t\t\tcoord = this.atlas.getEEGFFTData(channel);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcoord = this.atlas.getEEGDataByTag(channel);\n\t\t\t\t}\n\t\t\t\tif(coord !== false) {\n\t\t\t\t\tif(get === 'all') {\n\t\t\t\t\t\tget = coord.fftCount-coord.lastReadFFT;\n\t\t\t\t\t\tcoord.lastReadFFT = coord.fftCount;\n\t\t\t\t\t\tif(get === 0) return undefined;\n\t\t\t\t\t}\n\t\t\t\t\tlet fftTimes = coord.fftTimes.slice(coord.fftTimes.length - get, coord.fftTimes.length);\n\t\t\t\t\tlet ffts = coord.ffts.slice(coord.ffts.length - get,coord.ffts.length);\n\t\t\t\t\treturn {fftTimes:fftTimes, ffts:ffts};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tlet getCoherenceData = (tag, nArrays='all') => {\n\t\t\tlet get = nArrays;\n\t\t\tif(this.useAtlas === true) {\n\t\t\t\tlet coord = this.atlas.getCoherenceByTag(tag);\n\t\t\t\tif(get === 'all') {\n\t\t\t\t\tget = coord.fftCount-coord.lastRead;\n\t\t\t\t\tcoord.lastRead = coord.fftCount;\n\t\t\t\t\tif(get === 0) return undefined;\n\t\t\t\t}\n\t\t\t\tif(coord !== false) {\n\t\t\t\t\tlet cohTimes = coord.times.slice(coord.fftTimes.length - get, coord.fftTimes.length);\n\t\t\t\t\tlet ffts = coord.ffts.slice(coord.ffts.length - get,coord.ffts.length);\n\t\t\t\t\treturn {cohTimes:cohTimes, ffts:ffts};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthis.streamTable = [\n\t\t\t{prop:'EEG_Ch',  callback:getEEGChData},\n\t\t\t{prop:'EEG_FFT', callback:getEEGFFTData},\n\t\t\t{prop:'EEG_Coh', callback:getCoherenceData}\n\t\t];\n\t\tif(params.length > 0) {\n\t\t\tthis.streamTable.push(...params);\n\t\t}\n\t} \n\n\tconfigureStreamParams(props=[['prop','tag']]) { //Simply defines expected data parameters from the user for server-side reference\n\t\tlet propsToSend = [];\n\t\tprops.forEach((prop,i) => {\n\t\t\tpropsToSend.push(this.deviceName+\"_\"+prop[0]+\"_\"+prop[1]);\n\t\t});\n\t\tthis.socket.send(JSON.stringify({msg:['addProps',propsToSend],username:this.auth.username}));\n\t}\n\n\t//pass array of arrays defining which datasets you want to pull from according to the available\n\t// functions and additional required arguments from the streamTable e.g.: [['EEG_Ch','FP1',10],['EEG_FFT','FP1',1]]\n\tsendDataToSocket(params=[['prop','tag','count']],dataObj={}) {\n\t\tlet streamObj = {\n\t\t\tmsg:'data',\n\t\t\tusername:this.auth.username\n\t\t};\n\t\tObject.assign(streamObj,dataObj); //Append any extra data not defined by parameters from the stream table\n\t\tparams.forEach((param,i) => {\n\t\t\tthis.streamTable.find((option,i) => {\n\t\t\t\tif(param[0].indexOf(option.prop) > -1) {\n\t\t\t\t\tlet args = [...param].shift();\n\t\t\t\t\tlet result = option.callback(...args);\n\t\t\t\t\tif(result !== undefined) streamObj[this.deviceName+\"_\"+param.prop+\"_\"+tag] = result;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tthis.socket.send(JSON.stringify(streamObj));\n\t}\n\n\t//old method\n\tsendDataToServerOld(times=[],signals=[],electrodes='',fields='') {\n\t\tthis.socket.send(JSON.stringify({\n\t\t\tdestination:'bci',\n\t\t\tid:this.auth.username,\n\t\t\tconsent:this.auth.consent,\n\t\t\ttime:times,\n\t\t\tsignal:signals,\n\t\t\telectrode:electrodes,\n\t\t\tfield:fields\n\t\t}));\n\t}\n\n\tstreamLoop(prev={}) {\n\t\tlet params = [];\n\t\tif(this.streamParams.length === 0) { console.error('No stream parameters set'); return false;}\n\t\tthis.streamParams.forEach(([param],i) => {\n\t\t\tlet c = this.streamTable.find((o,i) => {\n\t\t\t\tlet newParam = [...param];\n\t\t\t\tif(o.prop === param[0]) {\n\t\t\t\t\tparams.push(newParam);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\tif(params.length > 0) { this.sendDataToSocket(params); }\n\n\t\tsetTimeout(() => {this.streamLoop();}, this.streamLoopTiming);\n\t}\n\n\tsimulateData() {\n\t\tlet delay = 100;\n\t\tif(this.simulating === true) {\n\t\t\tlet nSamplesToSim = Math.floor(this.sps*delay/1000);\n\t\t\tfor(let i = 0; i<nSamplesToSim; i++) {\n\t\t\t\t//For each tagged channel generate fake data\n\t\t\t\t//let sample = Math.sin(i*Math.PI/180);\n\t\t\t}\n\t\t\tsetTimeout(requestAnimationFrame(this.simulateData),delay);\n\t\t}\n\t}\n\n\tdisconnect() {\n\t\tif(this.deviceName.indexOf(\"FreeEEG\") > -1) {\n\t\t\tthis.device.disconnect();\n\t\t}\n\t\telse if (this.deviceName.indexOf(\"muse\") > -1) {\n\t\t\tthis.device.disconnect(); \n\t\t}\n\t\tthis.onDisconnect();\n\t}\n\n\t//Generic handlers to be called by devices, you can stage further processing and UI/State handling here\n\tonMessage(msg=\"\") {\n\t}\n\n\tonConnect(msg=\"\") {}\n\n\tonDisconnect(msg=\"\") {}\n}\n\n\nclass dataAtlas {\n    constructor(\n\t\tname=\"atlas\",\n\t\tinitialData={eegshared:{eegChannelTags:[{ch: 0, tag: null},{ch: 1, tag: null}],sps:512}},\n\t\teegConfig='10_20', //'muse','big'\n\t\tuseCoherence=true,\n\t\trunAnalyzer=false,\n\t\tanalysis=['fft'] //'fft','coherence','bcijs_bandpowers','heg_pulse'\n\t) {\n        this.name = name;\n\n        this.data = {\n\t\t\teegshared:{eegChannelTags:initialData.eegshared.eegChannelTags, sps:initialData.eegshared.sps, frequencies:[], bandFreqs:{scp:[[],[]], delta:[[],[]], theta:[[],[]], alpha1:[[],[]], alpha2:[[],[]], beta:[[],[]], lowgamma:[[],[]], highgamma:[[],[]]}},\n\t\t\teeg:[],\n\t\t\tcoherence:[],\n\t\t\theg:[],\n\t\t\tfnirs:[],\n\t\t\taccelerometer:[],\n\t\t\thrv:[],\n\t\t\tspo2:[],\n\t\t\temg:[],\n\t\t\tecg:[],\n\t\t\teyetracker:[]\n\t\t};\n\n\t\tthis.rolloverLimit = 30000; //Max samples allowed in arrays before rollover kicks in\n\n        if(eegConfig === '10_20') {\n            this.data.eeg = this.gen10_20Atlas();\n        }\n\t\telse if (eegConfig === 'muse') {\n\t\t\tthis.data.eeg = this.genMuseAtlas();\n\t\t}\n\t\telse if (eegConfig === 'big') {\n\t\t\tthis.data.eeg = this.genBigAtlas();\n\t\t}\n        if(useCoherence === true) {\n            this.data.coherence = this.genCoherenceMap(this.data.eegshared.eegChannelTags);\n        }\n\n\t\tthis.analyzing = runAnalyzer;\n\t\tthis.analysis = analysis;\n\t\tthis.analyzerOpts = []; //'eegfft','eegcoherence','bcijs_bandpower','bcijs_pca','heg_pulse'\n\t\tthis.analyzerFuncs = [];\n\t\tthis.workerPostTime = 0;\n\t\tthis.workerWaiting = false;\n\t\tthis.workerIdx = 0;\n\n\t\tif(runAnalyzer === true){\n\t\t\tthis.addDefaultAnalyzerFuncs();\n\t\t\tif(!window.workerResponses) { window.workerResponses = []; } //placeholder till we can get webworkers working outside of the index.html\n\t\t\t//this.workerIdx = window.addWorker(); // add a worker for this dataAtlas analyzer instance\n\t\t\twindow.workerResponses.push()\n\t\t\tthis.analyzer();\n\t\t}\n    }\n\n    genEEGCoordinateStruct(tag,x,y,z){\n        let bands = {scp:[],delta:[],theta:[],alpha1:[],alpha2:[],beta:[],lowgamma:[],highgamma:[]} \n        let struct = {\n            tag:tag, \n            position:{x:x,y:y,z:z}, \n            count:0,\n            times:[], \n            raw:[], \n            filtered:[], \n\t\t\tfftCount:0,\n\t\t\tfftTimes:[], //Separate timing for ffts on workers\n            ffts:[], \n            slices:JSON.parse(JSON.stringify(bands)), \n            means:JSON.parse(JSON.stringify(bands)),\n\t\t\tlastReadFFT:0, // counter value when this struct was last read from (using get functions)\n\t\t\tlastRead:0\n\t\t};\n        return struct;\n    }\n    \n    addEEGCoord(tag,x,y,z){\n\t\tthis.data.eeg.push(this.genEEGCoordinateStruct(tag,x,y,z));\n\t}\n\n\tgenMuseAtlas() { //Muse coordinates (estimated)\n\n\t\tlet eegmap = [];\n\n\t\tlet c = [[-21.5,70.2,-0.1],[28.4,69.1,-0.4],[-54.8,33.9,-3.5],\n\t\t[56.6,30.8,-4.1]]; //FP1, FP2, F7, F8\n\n\t\tfunction mid(arr1,arr2) { //midpoint\n\t\t\tmidpoint = [];\n\t\t\tarr1.forEach((el,i) => {\n\t\t\t\tmidpoint.push(0.5*(el*arr2[i]));\n\t\t\t})\n\t\t\treturn midpoint;\n\t\t}\n\n\t\tlet tags = ['FPZ','AF7','AF8','TP9','TP10'];\n\t\tlet coords = [\n\t\t\t[0.6,40.9,53.9],\n\t\t\t[mid(c[0],c[2])], //estimated\n\t\t\t[mid(c[1],c[3])], //estimated\n\t\t\t[-80.2,-31.3,-10.7], //estimated\n\t\t\t[81.9,-34.2,-8.2] //estimated\n\t\t];\n\n\t\ttags.forEach((tag,i) => {\n            eegmap.push(this.genEEGCoordinateStruct(tag,coords[i][0],coords[i][1],coords[i][2]));\n        });\n\n        return eegmap;\n\t}\n\n    gen10_20Atlas() { //19 channel EEG\n        let eegmap = [];\n        let tags = [\"FP1\",\"FP2\",\"FPZ\",\"F3\",\"F4\",\"F7\",\"F8\",\n                    \"CZ\",\"C3\",\"C4\",\"T3\",\"T4\",\"T5\",\"T6\",\"PZ\",\"P3\",\"P4\",\"O1\",\"O2\"];\n        let coords=[[-21.5,70.2,-0.1],[28.4,69.1,-0.4], //MNI coordinates\n                    [0.6,40.9,53.9],[-35.5,49.4,32.4],\n                    [40.2,47.6,32.1],[-54.8,33.9,-3.5],\n                    [56.6,30.8,-4.1],[0.8,-14.7,73.9],\n                    [-52.2,-16.4,57.8],[54.1,-18.0,57.5],\n                    [-70.2,-21.3,-10.7],[71.9,-25.2,-8.2],\n                    [-61.5,-65.3,1.1],[59.3,-67.6,3.8],\n                    [0.2,-62.1,64.5],[-39.4,-76.3,47.4],\n                    [36.8,-74.9,49.2],[-26.8,-100.2,12.8],\n                    [24.1,-100.5,14.1]];\n\n        tags.forEach((tag,i) => {\n            eegmap.push(this.genEEGCoordinateStruct(tag,coords[i][0],coords[i][1],coords[i][2]));\n        });\n\n        return eegmap;\n    }\n\n\tgenBigAtlas() {\n\n\t\tconst eegCoordinates = {\n\n\t\t\tFP1: [-21.2, 66.9, 12.1],\n\t\t\tFPZ: [1.4, 65.1, 11.3],\n\t\t\tFP2: [24.3, 66.3, 12.5],\n\t\t\tAF7: [-41.7, 52.8, 11.3],\n\t\t\tAF3: [-32.7, 48.4, 32.8],\n\t\t\tAFZ: [1.8, 54.8, 37.9],\n\t\t\tAF4: [35.1, 50.1, 31.1],\n\t\t\tAF8: [43.9, 52.7, 9.3],\n\t\t\tF5: [-51.4, 26.7, 24.7],\n\t\t\tF3: [-39.7, 25.3, 44.7],\n\t\t\tF1: [-22.1, 26.8, 54.9],\n\t\t\tFZ: [0.0, 26.8, 60.6],\n\t\t\tF2: [23.6, 28.2, 55.6],\n\t\t\tF4: [41.9, 27.5, 43.9],\n\t\t\tF6: [52.9, 28.7, 25.2],\n\t\t\tF7: [-52.1, 28.6, 3.8],\n\t\t\tF8: [53.2, 28.4, 3.1],\n\t\t\tFC5: [-59.1, 3.0, 26.1],\n\t\t\tFC3: [-45.5, 2.4, 51.3],\n\t\t\tFC1: [-24.7, 0.3, 66.4],\n\t\t\tFCZ: [1.0, 1.0, 72.8],\n\t\t\tFC2: [26.1, 3.2, 66.0],\n\t\t\tFC4: [47.5, 4.6, 49.7,],\n\t\t\tFC6: [60.5, 4.9, 25.5],\n\t\t\tFT9: [-53.8, -2.1, -29.1],\n\t\t\tFT7: [-59.2, 3.4, -2.1],\n\t\t\tFT8: [60.2, 4.7, -2.8],\n\t\t\tFT10: [55.0, -3.6, -31.0],\n\t\t\tT7: [-65.8, -17.8, -2.9],\n\t\t\tT5: [-61.5, -65.3, 1.1],\n\t\t\tT3: [-70.2, -21.3, -10.7],\n\t\t\tT4: [71.9,-25.2,-8.2],\n\t\t\tT6: [59.3, -67.6,  3.8],\n\t\t\tT8: [67.4, -18.5, -3.4],\n\t\t\tC5: [-63.6, -18.9, 25.8],\n\t\t\tC3: [-49.1, -20.7, 53.2],\n\t\t\tC1: [-25.1, -22.5, 70.1],\n\t\t\tCZ: [0.8, -21.9, 77.4],\n\t\t\tC2: [26.7, -20.9, 69.5],\n\t\t\tC4: [50.3, -18.8, 53.0],\n\t\t\tC6: [65.2, -18.0, 26.4],\n\t\t\tCP5: [-61.8, -46.2, 22.5],\n\t\t\tCP3: [-46.9, -47.7, 49.7],\n\t\t\tCP1: [-24.0, -49.1, 66.1],\n\t\t\tCPZ: [0.7, -47.9, 72.6],\n\t\t\tCP2: [25.8, -47.1, 66.0],\n\t\t\tCP4: [49.5, -45.5, 50.7],\n\t\t\tCP6: [62.9, -44.6, 24.4],\n\t\t\tTP9: [-73.6, -46.7, -4.0], // estimated\n\t\t\tTP7: [-63.6, -44.7, -4.0],\n\t\t\tTP8: [64.6, -45.4, -3.7],\t\t\n\t\t\tTP10: [74.6, -47.4, -3.7], // estimated\n\t\t\tP9: [-50.8, -51.3, -37.7],\n\t\t\tP7: [-55.9, -64.8, 0.0],\n\t\t\tP5: [-52.7, -67.1, 19.9],\n\t\t\tP3: [-41.4, -67.8, 42.4],\n\t\t\tP1: [-21.6, -71.3, 52.6],\n\t\t\tPZ: [0.7, -69.3, 56.9],\n\t\t\tP2: [24.4, -69.9, 53.5],\n\t\t\tP4: [44.2, -65.8, 42.7],\n\t\t\tP6: [54.4, -65.3, 20.2],\n\t\t\tP8: [56.4, -64.4, 0.1],\n\t\t\tP10: [51.0, -53.9, -36.5],\n\t\t\tPO7: [-44.0, -81.7, 1.6],\n\t\t\tPO3: [-33.3, -84.3, 26.5],\n\t\t\tPOZ: [0.0, -87.9, 33.5],\n\t\t\tPO4: [35.2, -82.6, 26.1],\n\t\t\tPO8: [43.3, -82.0, 0.7],\n\t\t\tO1: [-25.8, -93.3, 7.7],\n\t\t\tOz: [0.3, -97.1, 8.7],\n\t\t\tO2: [25.0, -95.2, 6.2],\n\t\t}\n\n\t\tlet eegmap = [];\n\t\tfor(const prop in eegCoordinates) {\n\t\t\teegmap.push(this.genEEGCoordinateStruct(prop,eegCoordinates[prop][0],eegCoordinates[prop][1],eegCoordinates[prop][2]));\n\t\t}\n\t}\n\n\tgenCoherenceStruct(tag0,tag1,coord0,coord1) {\n\t\tvar freqBins = {scp: [], delta: [], theta: [], alpha1: [], alpha2: [], beta: [], lowgamma: [], highgamma: []};\n\t\t\n\t\treturn {\n\t\t\ttag: tag0+\"_\"+tag1,\n\t\t\tx0: coord0?.x,\n\t\t\ty0: coord0?.y,\n\t\t\tz0: coord0?.z,\n\t\t\tx1: coord1?.x,\n\t\t\ty1: coord1?.y,\n\t\t\tz1: coord1?.z,\n\t\t\tfftCount: 0,\n\t\t\tfftTimes:[],\n\t\t\tffts:[],\n\t\t\tslices: JSON.parse(JSON.stringify(freqBins)),\n\t\t\tmeans: JSON.parse(JSON.stringify(freqBins)),  // counter value when this struct was last read from (for using get functions)\n\t\t\tlastRead:0\n\t\t}\n\t}\n\n    genCoherenceMap(channelTags = this.data.eegshared.eegChannelTags, taggedOnly = true) {\n\t\tvar cmap = [];\n\t\tvar l = 1, k = 0;\n\t\t\n\t\tfor( var i = 0; i < (channelTags.length*(channelTags.length + 1)/2)-channelTags.length; i++){\n\t\t\tif(taggedOnly === false || (taggedOnly === true && ((channelTags[k].tag !== null && channelTags[k+l].tag !== null)&&(channelTags[k].tag !== 'other' && channelTags[k+l].tag !== 'other')))) {\n\t\t\t\tvar coord0 = this.getEEGDataByTag(channelTags[k].tag);\n\t\t\t\tvar coord1 = this.getEEGDataByTag(channelTags[k+l].tag);\n\n\t\t\t\tcmap.push(this.genCoherenceStruct(channelTags[k].tag,channelTags[k+l].tag,coord0.position,coord1.position))\n\t\t\t}\n\t\t\tl++;\n\t\t\tif (l + k === channelTags.length) {\n\t\t\t\tk++;\n\t\t\t\tl = 1;\n\t\t\t}\n\t\t}\n\t\treturn cmap;\n\t}\n\n\tgenHEGStruct(tag,x,y,z) {\n\t\treturn {tag:tag,position:{x:x,y:y,z:z},times:[],red:[],ir:[],ambient:[],ratio:[],lastRead:0}\n\t}\n\n\taddHEGCoord(tag=\"heg1\",x,y,z) {\n\t\tthis.data.heg.push(this.genHEGStruct(tag,x,y,z));\n\t}\n\n\tgenFNIRSStruct(tag,x,y,z) {\n\t\treturn {tag:tag,position:{x:x,y:y,z:z},times:[],red:[],ir:[],ir2:[],ambient:[],lastRead:0}\n\t}\n\n\taddFNIRSCoord(tag=\"banana1\",x,y,z) {\n\t\tthis.data.fnirs.push(this.genHEGStruct(tag,x,y,z));\n\t}\n\n\tgenAccelerometerStruct(tag,x,y,z) {\n\t\treturn {tag:tag,position:{x:x,y:y,z:z},times:[],Ax:[],Ay:[],Az:[],Gx:[],Gy:[],Gz:[],lastRead:0};\n\t}\n\n\taddAccelerometerCoord(tag=\"accel1\",x,y,z){\n\t\tthis.data.accelerometer.push(this.genAccelerometerStruct(tag,x,y,z));\n\t}\n\n\tgenHRVStruct(tag){\n\t\treturn {tag:tag, times:[], raw:[], filtered:[], bpm:[], hrv:[],lastRead:0}\n\t}\n\n\taddHRV(tag=\"hrv1\") {\n\t\tthis.data.hrv.push(genHRVStruct(tag));\n\t}\n\n\t//ecg,emg,eyetracker\n\n\tgetEEGDataByChannel(ch=0) {\n\t\tlet found = false;\n\t\tlet search = this.channelTags.find((o,i) => {\n\t\t\tif(o.ch === ch) {\n\t\t\t\tfound = this.getEEGDataByTag(o.tag);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn found;\n\t}\n\n    //Return the object corresponding to the atlas tag\n\tgetEEGDataByTag(tag=\"FP1\"){\n\t\tvar found = undefined;\n\t\tlet atlasCoord = this.data.eeg.find((o, i) => {\n\t\t\tif(o.tag === tag){\n\t\t\t\tfound = o;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn found;\n\t}\n\n\n    //Return the object corresponding to the atlas tag\n\tgetCoherenceByTag(tag=\"FP1_FZ\"){\n\t\tvar found = undefined;\n\t\tlet atlasCoord = this.data.coherence.find((o, i) => {\n\t\t\tif(o.tag === tag){\n\t\t\t\tfound = o;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\treturn found;\n\t}\n\n    //Return an array of Array(3)s for each coordinate. Useful e.g. for graphics\n\tgetCoordPositions() {\n\t\tvar coords = [];\n\t\tfor(var i = 0; i< this.data.eeg.length; i++) {\n\t\t\tcoords.push([this.data.eeg[i].position.x,this.data.eeg[i].position.y,this.data.eeg[i].position.z]);\n\t\t}\n\t\treturn coords;\n\t}\n\n    //Get the latest data pushed to tagged channels\n\tgetLatestFFTData() {\n\t\tlet dat = [];\n\t\tthis.data.eegshared.eegChannelTags.forEach((r, i) => {\n\t\t\tlet row = this.getDataByTag(r.tag);\n\t\t\tlet lastIndex = row.fftCount - 1;\n\t\t\tdat.push({\n                tag:row.tag,\n\t\t\t\tfftCount:row.fftCount,\n\t\t\t\ttime: row.fftTimes[lastIndex],\n\t\t\t\tfft: row.ffts[lastIndex],\n\t\t\t\tslice:{delta:row.slices.delta[lastIndex], theta:row.slices.theta[lastIndex], alpha1:row.slices.alpha1[lastIndex], alpha2:row.slices.alpha2[lastIndex], beta:row.slices.beta[lastIndex], gamma:row.slices.gamma[lastIndex]},\n\t\t\t\tmean:{delta:row.means.delta[lastIndex], theta:row.means.theta[lastIndex], alpha1: row.means.alpha1[lastIndex], alpha2: row.means.alpha2[lastIndex], beta: row.means.beta[lastIndex], gamma: row.means.gamma[lastIndex]}\n\t\t\t});\n\t\t});\n\t\treturn dat;\n\t}\n\n\tgetLatestCoherenceData() {\n\t\tlet dat = [];\n\t\tthis.data.coherence.forEach((row,i) => {\n\t\t\tlet lastIndex = row.fftCount - 1;\n\t\t\tdat.push({\n\t\t\t\ttag:row.tag,\n\t\t\t\tfftCount:row.fftCount,\n\t\t\t\ttime: row.times[lastIndex],\n\t\t\t\tfft: row.ffts[lastIndex],\n\t\t\t\tslice:{delta:row.slices.delta[lastIndex], theta:row.slices.theta[lastIndex], alpha1:row.slices.alpha1[lastIndex], alpha2:row.slices.alpha2[lastIndex], beta:row.slices.beta[lastIndex], gamma:row.slices.gamma[lastIndex]},\n\t\t\t\tmean:{delta:row.means.delta[lastIndex], theta:row.means.theta[lastIndex], alpha1: row.means.alpha1[lastIndex], alpha2: row.means.alpha2[lastIndex], beta: row.means.beta[lastIndex], gamma: row.means.gamma[lastIndex]}\n\t\t\t});\n\t\t});\n\t\treturn dat;\n\t}\n\n    setDefaultTags() {\n\t\treturn [\n\t\t\t{ch: 0, tag: null},{ch: 1, tag: null},{ch: 2, tag: null},{ch: 3, tag: null},\n\t\t\t{ch: 4, tag: null},{ch: 5, tag: null},{ch: 6, tag: null},{ch: 7, tag: null},\n\t\t\t{ch: 8, tag: null},{ch: 9, tag: null},{ch: 10, tag: null},{ch: 11, tag: null},\n\t\t\t{ch: 12, tag: null},{ch: 13, tag: null},{ch: 14, tag: null},{ch: 15, tag: null},\n\t\t\t{ch: 16, tag: null},{ch: 17, tag: null},{ch: 18, tag: null},{ch: 19, tag: null},\n\t\t\t{ch: 20, tag: null},{ch: 21, tag: null},{ch: 22, tag: null},{ch: 23, tag: null},\n\t\t\t{ch: 24, tag: null},{ch: 25, tag: null},{ch: 26, tag: null},{ch: 27, tag: null},\n\t\t\t{ch: 28, tag: null},{ch: 29, tag: null},{ch: 30, tag: null},{ch: 31, tag: null}\n\t\t];\n\t}\n\n    getBandFreqs(frequencies) {//Returns an object with the frequencies and indices associated with the bandpass window (for processing the FFT results)\n\t\tvar scpFreqs = [[],[]], deltaFreqs = [[],[]], thetaFreqs = [[],[]], alpha1Freqs = [[],[]], alpha2Freqs = [[],[]], betaFreqs = [[],[]], lowgammaFreqs = [[],[]], highgammaFreqs = [[],[]]; //x axis values and indices for named EEG frequency bands\n\t\tfrequencies.forEach((item,idx) => {\n\t\t\tif((item >= 0.1) && (item <= 1)){\n\t\t\t\tscpFreqs[0].push(item); scpFreqs[1].push(idx);\n\t\t\t}\n\t\t\telse if((item >= 1) && (item <= 4)){\n\t\t\t\tdeltaFreqs[0].push(item); deltaFreqs[1].push(idx);\n\t\t\t}\n\t\t\telse if((item > 4) && (item <= 8)) {\n\t\t\t\tthetaFreqs[0].push(item); thetaFreqs[1].push(idx);\n\t\t\t}\n\t\t\telse if((item > 8) && (item <= 10)){\n\t\t\t\talpha1Freqs[0].push(item); alpha1Freqs[1].push(idx);\n\t\t\t}\n\t\t\telse if((item > 10) && (item <= 12)){\n\t\t\t\talpha2Freqs[0].push(item); alpha2Freqs[1].push(idx);\n\t\t\t}\n\t\t\telse if((item > 12) && (item <= 35)){\n\t\t\t\tbetaFreqs[0].push(item); betaFreqs[1].push(idx);\n\t\t\t}\n\t\t\telse if((item > 35) && (item <= 48)) {\n\t\t\t\tlowgammaFreqs[0].push(item); lowgammaFreqs[1].push(idx);\n\t\t\t}\n\t\t\telse if(item > 48) {\n\t\t\t\thighgammaFreqs[0].push(item); highgammaFreqs[1].push(idx);\n\t\t\t}\n\t\t});\n\t\treturn {scp: scpFreqs, delta: deltaFreqs, theta: thetaFreqs, alpha1: alpha1Freqs, alpha2: alpha2Freqs, beta: betaFreqs, lowgamma: lowgammaFreqs, highgamma: highgammaFreqs}\n\t}\n\n    mapFFTData = (fft, lastPostTime, tag) => {\n\t\tlet atlasCoord = this.data.eeg.find((o, i) => {\n\t\tif(o.tag === tag){\n\t\t\tthis.data.eeg[i].fftCount++;\n\t\t\tthis.data.eeg[i].fftTimes.push(lastPostTime);\n\t\t\tthis.data.eeg[i].ffts.push(fft);\n\t\t\tif(this.data.eegshared.bandFreqs.scp[1].length > 0){\n\t\t\tvar scp = fft.slice( this.data.eegshared.bandFreqs.scp[1][0], this.data.eegshared.bandFreqs.scp[1][this.data.eegshared.bandFreqs.scp[1].length-1]+1);\n\t\t\tthis.data.eeg[i].data.slices.scp.push(scp);\n\t\t\tthis.data.eeg[i].data.means.scp.push(eegmath.mean(scp));\n\t\t\t}\n\t\t\tif(this.data.eegshared.bandFreqs.scp[1].length > 0){\n\t\t\tvar delta = fft.slice( this.data.eegshared.bandFreqs.delta[1][0], this.data.eegshared.bandFreqs.delta[1][this.data.eegshared.bandFreqs.delta[1].length-1]+1);\n\t\t\tthis.data.eeg[i].slices.delta.push(delta);\n\t\t\tthis.data.eeg[i].means.delta.push(eegmath.mean(delta));\n\t\t\t}\n\t\t\tif(this.data.eegshared.bandFreqs.theta[1].length > 0){\n\t\t\tvar theta = fft.slice( this.data.eegshared.bandFreqs.theta[1][0], this.data.eegshared.bandFreqs.theta[1][this.data.eegshared.bandFreqs.theta[1].length-1]+1);\n\t\t\tthis.data.eeg[i].slices.theta.push(theta);\n\t\t\tthis.data.eeg[i].means.theta.push(eegmath.mean(theta));\n\t\t\t}\n\t\t\tif(this.data.eegshared.bandFreqs.alpha1[1].length > 0){\n\t\t\tvar alpha1 = fft.slice( this.data.eegshared.bandFreqs.alpha1[1][0], this.data.eegshared.bandFreqs.alpha1[1][this.data.eegshared.bandFreqs.alpha1[1].length-1]+1);\n\t\t\tthis.data.eeg[i].slices.alpha1.push(alpha1);\n\t\t\tthis.data.eeg[i].means.alpha1.push(eegmath.mean(alpha1));\n\t\t\t}\n\t\t\tif(this.data.eegshared.bandFreqs.alpha2[1].length > 0){\n\t\t\tvar alpha2 = fft.slice( this.data.eegshared.bandFreqs.alpha2[1][0], this.data.eegshared.bandFreqs.alpha2[1][this.data.eegshared.bandFreqs.alpha2[1].length-1]+1);\n\t\t\tthis.data.eeg[i].slices.alpha2.push(alpha2);\n\t\t\tthis.data.eeg[i].means.alpha2.push(eegmath.mean(alpha2));\n\t\t\t}\n\t\t\tif(this.data.eegshared.bandFreqs.beta[1].length > 0){\n\t\t\tvar beta  = fft.slice( this.data.eegshared.bandFreqs.beta[1][0],  this.data.eegshared.bandFreqs.beta[1][this.data.eegshared.bandFreqs.beta[1].length-1]+1);\n\t\t\tthis.data.eeg[i].slices.beta.push(beta);\n\t\t\tthis.data.eeg[i].means.beta.push(eegmath.mean(beta));\n\t\t\t}\n\t\t\tif(this.data.eegshared.bandFreqs.lowgamma[1].length > 0){\n\t\t\tvar lowgamma = fft.slice( this.data.eegshared.bandFreqs.lowgamma[1][0], this.data.eegshared.bandFreqs.lowgamma[1][this.data.eegshared.bandFreqs.lowgamma[1].length-1]+1);\n\t\t\tthis.data.eeg[i].slices.lowgamma.push(lowgamma);\n\t\t\tthis.data.eeg[i].means.lowgamma.push(eegmath.mean(lowgamma));\n\t\t\t}\n\t\t\tif(this.data.eegshared.bandFreqs.highgamma[1].length > 0){\n\t\t\tvar highgamma = fft.slice( this.data.eegshared.bandFreqs.highgamma[1][0], this.data.eegshared.bandFreqs.highgamma[1][this.data.eegshared.bandFreqs.highgamma[1].length-1]+1);\n\t\t\tthis.data.eeg[i].slices.highgamma.push(highgamma);\n\t\t\tthis.data.eeg[i].means.highgamma.push(eegmath.mean(highgamma));\n\t\t\t}\n\t\t\t//console.timeEnd(\"slicing bands\");\n\t\t\treturn true;\n\t\t}\n\t\t});\n\t}\n\n    mapCoherenceData = (data, lastPostTime) => { //Expects data in correct order\n\t\tdata.forEach((row,i) => {\n\t\t  this.data.coherence[i].fftCount++;\n\t\t  this.data.coherence[i].amplitudes.push(row);\n\t\t  this.data.coherence[i].fftTimes.push(lastPostTime);\n\n\t\tif(this.data.eegshared.bandFreqs.scp[1].length > 0){\n\t\t  var scp = row.slice( this.data.eegshared.bandFreqs.scp[1][0], this.data.eegshared.bandFreqs.scp[1][this.data.eegshared.bandFreqs.scp[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.scp.push(scp);\n\t\t  this.data.coherence[i].means.scp.push(eegmath.mean(scp));\n\t\t}\n\t\tif(this.data.eegshared.bandFreqs.delta[1].length > 0){\n\t\t  var delta = row.slice( this.data.eegshared.bandFreqs.delta[1][0], this.data.eegshared.bandFreqs.delta[1][this.data.eegshared.bandFreqs.delta[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.delta.push(delta);\n\t\t  this.data.coherence[i].means.delta.push(eegmath.mean(delta));\n\t\t}\n\t\tif(this.data.eegshared.bandFreqs.theta[1].length > 0){\n\t\t  var theta = row.slice( this.shared.bandFreqs.theta[1][0], this.data.eegshared.bandFreqs.theta[1][this.data.eegshared.bandFreqs.theta[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.theta.push(theta);\n\t\t  this.data.coherence[i].means.theta.push(eegmath.mean(theta));\n\t\t}\n\t\tif(this.data.eegshared.bandFreqs.alpha1[1].length > 0){\n\t\t  var alpha1 = row.slice( this.shared.bandFreqs.alpha1[1][0], this.data.eegshared.bandFreqs.alpha1[1][this.data.eegshared.bandFreqs.alpha1[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.alpha1.push(alpha1);\n\t\t  this.data.coherence[i].means.alpha1.push(eegmath.mean(alpha1));\n\t\t}\n\t\tif(this.data.eegshared.bandFreqs.alpha2[1].length > 0){\n\t\t  var alpha2 = row.slice( this.data.eegshared.bandFreqs.alpha2[1][0], this.data.eegshared.bandFreqs.alpha2[1][this.data.eegshared.bandFreqs.alpha2[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.alpha2.push(alpha2);\n\t\t  this.data.coherence[i].means.alpha2.push(eegmath.mean(alpha2));\n\t\t}\n\t\tif(this.data.eegshared.bandFreqs.beta[1].length > 0){\n\t\t  var beta = row.slice( this.data.eegshared.bandFreqs.beta[1][0],  this.data.eegshared.bandFreqs.beta[1][this.data.eegshared.bandFreqs.beta[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.beta.push(beta);\n\t\t  this.data.coherence[i].means.beta.push(eegmath.mean(beta));\n\t\t}\n\t\tif(this.data.eegshared.bandFreqs.lowgamma[1].length > 0){\n\t\t  var lowgamma = row.slice( this.data.eegshared.bandFreqs.lowgamma[1][0], this.data.eegshared.bandFreqs.lowgamma[1][this.data.eegshared.bandFreqs.lowgamma[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.lowgamma.push(lowgamma);\n\t\t  this.data.coherence[i].means.lowgamma.push(eegmath.mean(lowgamma));\n\t\t}\n\t\tif(this.data.eegshared.bandFreqs.highgamma[1].length > 0){\n\t\t  var highgamma = row.slice( this.data.eegshared.bandFreqs.highgamma[1][0], this.data.eegshared.bandFreqs.highgamma[1][this.data.eegshared.bandFreqs.highgamma[1].length-1]+1);\n\t\t  this.data.coherence[i].slices.highgamma.push(highgamma);\n\t\t  this.data.coherence[i].means.highgamma.push(eegmath.mean(highgamma));\n\t\t}\n\t\t});\n\t}\n    \n    //Returns the x axis (frequencies) for the bandpass filter amplitudes. The window gets stretched or squeezed between the chosen frequencies based on the sample rate in my implementation.\n\tbandpassWindow(freqStart,freqEnd,nSteps) {\n\n\t\tvar freqEnd_nyquist = freqEnd*2;\n\t\tvar fftwindow = [];\n\t\t  for (var i = 0; i < Math.ceil(0.5*nSteps); i++){\n\t\t\t  fftwindow.push(freqStart + (freqEnd_nyquist-freqStart)*i/(nSteps));\n\t\t  }\n\t\treturn fftwindow;\n\t}\n\n\tbufferEEGSignals = (seconds=1) => { //Buffers 1 second of all tagged eeg signals (unless null or 'other'). Data buffered in order of objects in the eeg array\n\t\tlet nSamples = Math.floor(this.data.eegshared.sps * seconds);\n\t\tlet buffer = [];\n\t\tlet syncTime = null;\n\t\tfor(var i = 0; i < this.data.eegshared.eegChannelTags.length; i++){\n\t\t\tif(this.data.eegshared.eegChannelTags[i].tag !== null && this.data.eegshared.eegChannelTags[i].tag !== 'other') {\n\t\t\t\tlet dat = this.getEEGDataByTag(this.data.eegshared.eegChannelTags[i].tag);\n\t\t\t\tif(dat !== undefined) {\n\t\t\t\t\t//console.log(dat);\n\t\t\t\t\tif(dat.filtered.length > 0) {buffer.push(dat.filtered.slice(dat.filtered.length-nSamples,dat.filtered.length));}\n\t\t\t\t\telse if (dat.raw.length > 0) {buffer.push(dat.raw.slice(dat.raw.length-nSamples,dat.raw.length));}\n\t\t\t\t\tif(syncTime === null) {\n\t\t\t\t\t\tsyncTime = dat.times[dat.times.length-1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(this.analyzing === true) { this.workerPostTime = syncTime; }\n\t\treturn buffer;\n\t} \n\n\tworkerOnMessage(msg) {\n\t\tif(msg.origin === this.name) {\n\t\t\tif(msg.foo === \"multidftbandpass\" || msg.foo === \"multidft\") { \n\t\t\t\t//parse data into atlas\n\t\t\t\tvar ffts = [...msg.output[1]];\n\t\t\t\tthis.data.eegshared.eegChannelTags.forEach((row,i) => {\n\t\t\t\t\tif(row.tag !== null && row.tag !== 'other') {\n\t\t\t\t\t\tthis.mapFFTData(ffts,this.workerPostTime,row.tag);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse if(msg.foo === \"coherence\"){ \n\t\t\t\tvar ffts = [...msg.output[1]];\n\t\t\t\tvar coher = [...msg.output[2]];\n\t\t\t\tthis.data.eegshared.eegChannelTags.forEach((row,i) => {\n\t\t\t\t\tif(row.tag !== null && row.tag !== 'other') {\n\t\t\t\t\t\tthis.mapFFTData(ffts,this.workerPostTime,row.tag);\n\t\t\t\t\t}\n\t\t\t\t\tthis.mapCoherenceData(coher,this.workerPostTime);\n\t\t\t\t});\n\t\t\t\t//coherence\n\t\t\t}\n\t\t\tthis.workerWaiting = false;\n\t\t}\n\t}\n\n\taddDefaultAnalyzerFuncs() {\n\t\tthis.analyzerOpts.push('eegfft','eegcoherence');\n\t\tlet fftFunc = () => {\n\t\t\tif(this.workerWaiting === false){\n\t\t\t\tlet buf = this.bufferEEGSignals(1);\n\t\t\t\twindow.postToWorker({foo:'coherence', input:[buf, 1, 0, this.data.eegshared.sps*0.5, 1], origin:this.name},this.workerIdx);\n\t\t\t\t//window.postToWorker({foo:'gpucoh', input:[buf, 1, 0, this.data.eegshared.sps*0.5, 1], origin:this.name},this.workerIdx);\n\t\t\t\tthis.workerWaiting = true;\n\t\t\t}\n\t\t}\n\t\tlet coherenceFunc = () => {\n\t\t\tif(this.workerWaiting === false){\n\t\t\t\tlet buf = this.bufferEEGSignals(1);\n\t\t\t\twindow.postToWorker({foo:'multidftbandpass', input:[buf, 1, 0, this.data.eegshared.sps*0.5, 1], origin:this.name},this.workerIdx);\n\t\t\t\tthis.workerWaiting = true;\n\t\t\t}\n\t\t}\t\n\t\t//add other worker functions (see eegworker.js)\n\n\t\tthis.analyzerFuncs.push(fftFunc,coherenceFunc);\n\t\t//'bcijs_bandpowers','bcijs_pca','heg_pulse'\n\t}\n\n\taddAnalyzerFunc(name='',foo=()=>{}) {\n\t\tlet n = this.analyzerOpts.find((name,i) => {\n\t\t\tif(name === name) {\n\t\t\t\tthis.analyzerFuncs[i] = foo;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tif(n === undefined) {\n\t\t\tthis.analyzerOpts.push(name);\n\t\t\tthis.analyzerFuncs.push(foo);\n\t\t}\n\t}\n\n\taddAnalysisMode(name='') { //eegfft,eegcoherence,bcijs_bandpower,bcijs_pca,heg_pulse\n\t\tlet found = this.analysis.find((str,i) => {\n\t\t\tif(name === str) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t});\n\t\tif(found === undefined) {\n\t\t\tthis.analysis.push(name);\n\t\t}\n\t}\n\n\tcheckRollover(dataArr=null) { //'eeg','heg', etc\n\t\tif(dataArr === null) {\n\t\t\tfor(const prop in this.data) {\n\t\t\t\tif(Array.isArray(this.data[prop])) {\n\t\t\t\t\tthis.data[prop].forEach((row,i) => {\n\t\t\t\t\t\tfor(const p in row) {\n\t\t\t\t\t\t\tif((!Array.isArray(row[p])) && typeof row[p] === 'object') {\n\t\t\t\t\t\t\t\tfor(const pz in row[p]) {\n\t\t\t\t\t\t\t\t\tif(Array.isArray(row[p][pz])) {\n\t\t\t\t\t\t\t\t\t\tif(row[p][pz].length > this.rolloverLimit) {row[p][pz].splice(0,this.row[p][pz].length-this.rolloverLimit);}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(Array.isArray(row[p])) {\n\t\t\t\t\t\t\t\tif(row[p].length > this.rolloverLimit) {row[p].splice(0,this.row[p].length-this.rolloverLimit);}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse { //spaghetti\n\t\t\tif(Array.isArray(this.data[dataArr])) {\n\t\t\t\tthis.data[dataArr].forEach((row,i) => {\n\t\t\t\t\tfor(const p in row) {\n\t\t\t\t\t\tif((!Array.isArray(row[p])) && typeof row[p] === 'object') { //nested object with arrays\n\t\t\t\t\t\t\tfor(const pz in row[p]) {\n\t\t\t\t\t\t\t\tif(Array.isArray(row[p][pz])) {\n\t\t\t\t\t\t\t\t\tif(row[p][pz].length > this.rolloverLimit) {row[p][pz].splice(0,this.row[p][pz].length-this.rolloverLimit);}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(Array.isArray(row[p])) { //arrays\n\t\t\t\t\t\t\tif(row[p].length > this.rolloverLimit) {row[p].splice(0,this.row[p].length-this.rolloverLimit);}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}\n\n\tanalyzer = () => {\n\t\t//fft,coherence,bcijs_bandpowers,bcijs_pca,heg_pulse\n\n\t\tthis.analysis.forEach((run,i) => {\n\t\t\tthis.analyzerOpts.forEach((opt,j) => {\n\t\t\t\tif(opt === run) {\n\t\t\t\t\tthis.analyzerFuncs[j]();\n\t\t\t\t}\n\t\t\t});\n\t\t});\n\t\t\t\n\t\tsetTimeout(()=>{requestAnimationFrame(this.analyzer)},20);\n\t}\n}\n"},685:t=>{t.exports=function(t){function e(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):e("EvalError: No eval function available")}catch(t){e(t)}}}},e={};function n(a){var s=e[a];if(void 0!==s)return s.exports;var i=e[a]={exports:{}};return t[a](i,i.exports,n),i.exports}n(685)(n(980)),brainsatplay={}})();