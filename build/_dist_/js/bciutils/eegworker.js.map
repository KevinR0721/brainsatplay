{
  "version": 3,
  "sources": ["/Users/garrettflynn/Documents/Github/eegpwatestground/src/js/bciutils/eegworker.mjs"],
  "sourcesContent": ["//var full = location.protocol + location.pathname;\n//var localpath = full.substr(0,full.lastIndexOf(\"/\"));\n//var parentpath = localpath.substr(0,localpath.lastIndexOf(\"/\"));\n\nimport { gpuUtils } from './signal_analysis/gpuUtils.js';\nimport { eegmath } from './eegmath';\n\nconst gpu = new gpuUtils();\n\nonmessage = (e) => {\n  // define gpu instance\n  //console.log(\"worker executing...\")\n  console.time(\"worker\");\n  let output = \"function not defined\";\n\n  switch (e.data.foo) {\n    case \"xcor\": // Takes 2 1D arrays\n      output = eegmath.crosscorrelation(e.data.input[0],e.data.input[1]);\n      break;\n    case \"autocor\": // Takes 1 1D array\n      output = eegmath.autocorrelation(e.data.input);\n      break;\n    case \"cov1d\": // Takes 2 1D arrays\n      output = eegmath.cov1d(e.data.input[0],e.data.input[1]);\n      break;\n    case \"cov2d\": // Takes 1 2D array with equal width rows\n      output = eegmath.cov2d(e.data.input);\n      break;\n    case \"sma\": // Takes 1 1D array and an sma window size\n      output = eegmath.sma(e.data.input[0],e.data.input[1]);\n      break;\n    case \"dft\": // Takes 1 1D array and the number of seconds, and an optional scalar value\n      var scalar = 1;\n      if(e.data.input[2] !== undefined) scalar = e.data.input[2];\n      output = gpu.gpuDFT(e.data.input[0],e.data.input[1],scalar);\n      break;\n    case \"multidft\": //Takes 1 2D array with equal width rows, and the number of seconds of data being given\n      var scalar = 1;\n      if(e.data.input[2] !== undefined) scalar = e.data.input[2];\n      output = gpu.MultiChannelDFT(e.data.input[0],e.data.input[1],scalar);\n      break;\n    case \"multidftbandpass\": //Accepts 1 2D array of equal width, number of seconds of data, beginning frequency, ending frequency\n      var scalar = 1;\n      if(e.data.input[4] !== undefined) scalar = e.data.input[4];\n      output = gpu.MultiChannelDFT_Bandpass(e.data.input[0],e.data.input[1],e.data.input[2],e.data.input[3],scalar);\n      break;\n    case \"gpucoh\":\n      const coher = gpu.gpuCoherence(e.data.input[0],e.data.input[1],e.data.input[2],e.data.input[3],e.data.input[4]);\n      output = coher;\n      break;\n    case \"coherence\": // Input 2D array, number of seconds, beginning frequency, ending frequency. Outputs an array of products of each FFT with each associated correlogram to create a network map of all available channels, ordered by channel\n      const correlograms = eegmath.correlograms(e.data.input[0]);\n      const buffer = [...e.data.input[0],...correlograms];\n      var dfts;\n\n      var scalar = 1;\n      //console.log(mins)\n      //console.log(buffer);\n      dfts = gpu.MultiChannelDFT_Bandpass(buffer, e.data.input[1], e.data.input[2], e.data.input[3], scalar);\n      //console.log(dfts)\n      const cordfts = dfts[1].splice(e.data.input[0].length, buffer.length-e.data.input[0].length);\n      //console.log(cordfts)\n\n      const coherenceResults = [];\n      const nChannels = e.data.input[0].length;\n\n      //cross-correlation dfts arranged like e.g. for 4 channels: [0:0, 0:1, 0:2, 0:3, 1:1, 1:2, 1:3, 2:2, 2:3, 3:3] etc.\n      var k=0;\n      var l=0;\n      cordfts.forEach((row,i) => { //move autocorrelation results to front to save brain power\n        if (l+k === nChannels) {\n          var temp = cordfts.splice(i,1);\n          k++;\n          cordfts.splice(k,0,...temp);\n          l=0;\n          //console.log(i);\n        }\n        l++;\n      });\n      //Now arranged like [0:0,1:1,2:2,3:3,0:1,0:2,0:3,1:2,1:3,2:3]\n\n      //Outputs FFT coherence data in order of channel data inputted e.g. for 4 channels resulting DFTs = [0:1,0:2,0:3,1:2,1:3,2:3];\n\n      var autoFFTproducts = [];\n      k = 0;\n      l = 1;\n      cordfts.forEach((dft,i) => {\n        var newdft = new Array(dft.length).fill(0);\n        if(i < nChannels) { //sort out autocorrelogram FFTs\n          dft.forEach((amp,j) => {\n            newdft[j] = amp//*dfts[1][i][j];\n          });\n          autoFFTproducts.push(newdft);\n        }\n        else{ //now multiply cross correlogram ffts and divide by autocorrelogram ffts (magnitude squared coherence)\n          dft.forEach((amp,j) => {\n              newdft[j] = amp*amp/(autoFFTproducts[k][j]*autoFFTproducts[k+l][j]);//Magnitude squared coherence;\n              if(newdft[j] > 1) { newdft[j] = 1; } //caps the values at 1\n              //newdft[j] = Math.pow(newdft[j],.125)\n          });\n          l++;\n          if((l+k) === nChannels) {\n            k++;\n            l = 1;\n          }\n          coherenceResults.push(newdft);\n        }\n      });\n      output = [dfts[0], dfts[1], coherenceResults];\n\n\n      break;\n\n  }\n\n  // output some results!\n  console.timeEnd(\"worker\");\n  \n  postMessage({output: output, foo: e.data.foo, origin: e.data.origin});\n};\n"],
  "mappings": "AAIA;AACA;AAEA,MAAM,MAAM,IAAI;AAEhB,YAAY,CAAC,MAAM;AAGjB,UAAQ,KAAK;AACb,MAAI,SAAS;AAEb,UAAQ,EAAE,KAAK;AAAA,SACR;AACH,eAAS,QAAQ,iBAAiB,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM;AAC/D;AAAA,SACG;AACH,eAAS,QAAQ,gBAAgB,EAAE,KAAK;AACxC;AAAA,SACG;AACH,eAAS,QAAQ,MAAM,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM;AACpD;AAAA,SACG;AACH,eAAS,QAAQ,MAAM,EAAE,KAAK;AAC9B;AAAA,SACG;AACH,eAAS,QAAQ,IAAI,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM;AAClD;AAAA,SACG;AACH,UAAI,SAAS;AACb,UAAG,EAAE,KAAK,MAAM,OAAO;AAAW,iBAAS,EAAE,KAAK,MAAM;AACxD,eAAS,IAAI,OAAO,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG;AACpD;AAAA,SACG;AACH,UAAI,SAAS;AACb,UAAG,EAAE,KAAK,MAAM,OAAO;AAAW,iBAAS,EAAE,KAAK,MAAM;AACxD,eAAS,IAAI,gBAAgB,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG;AAC7D;AAAA,SACG;AACH,UAAI,SAAS;AACb,UAAG,EAAE,KAAK,MAAM,OAAO;AAAW,iBAAS,EAAE,KAAK,MAAM;AACxD,eAAS,IAAI,yBAAyB,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG;AACtG;AAAA,SACG;AACH,YAAM,QAAQ,IAAI,aAAa,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM,IAAG,EAAE,KAAK,MAAM;AAC5G,eAAS;AACT;AAAA,SACG;AACH,YAAM,eAAe,QAAQ,aAAa,EAAE,KAAK,MAAM;AACvD,YAAM,SAAS,CAAC,GAAG,EAAE,KAAK,MAAM,IAAG,GAAG;AACtC,UAAI;AAEJ,UAAI,SAAS;AAGb,aAAO,IAAI,yBAAyB,QAAQ,EAAE,KAAK,MAAM,IAAI,EAAE,KAAK,MAAM,IAAI,EAAE,KAAK,MAAM,IAAI;AAE/F,YAAM,UAAU,KAAK,GAAG,OAAO,EAAE,KAAK,MAAM,GAAG,QAAQ,OAAO,SAAO,EAAE,KAAK,MAAM,GAAG;AAGrF,YAAM,mBAAmB;AACzB,YAAM,YAAY,EAAE,KAAK,MAAM,GAAG;AAGlC,UAAI,IAAE;AACN,UAAI,IAAE;AACN,cAAQ,QAAQ,CAAC,KAAI,MAAM;AACzB,YAAI,IAAE,MAAM,WAAW;AACrB,cAAI,OAAO,QAAQ,OAAO,GAAE;AAC5B;AACA,kBAAQ,OAAO,GAAE,GAAE,GAAG;AACtB,cAAE;AAAA;AAGJ;AAAA;AAMF,UAAI,kBAAkB;AACtB,UAAI;AACJ,UAAI;AACJ,cAAQ,QAAQ,CAAC,KAAI,MAAM;AACzB,YAAI,SAAS,IAAI,MAAM,IAAI,QAAQ,KAAK;AACxC,YAAG,IAAI,WAAW;AAChB,cAAI,QAAQ,CAAC,KAAI,MAAM;AACrB,mBAAO,KAAK;AAAA;AAEd,0BAAgB,KAAK;AAAA,eAEnB;AACF,cAAI,QAAQ,CAAC,KAAI,MAAM;AACnB,mBAAO,KAAK,MAAI,MAAK,iBAAgB,GAAG,KAAG,gBAAgB,IAAE,GAAG;AAChE,gBAAG,OAAO,KAAK,GAAG;AAAE,qBAAO,KAAK;AAAA;AAAA;AAGpC;AACA,cAAI,IAAE,MAAO,WAAW;AACtB;AACA,gBAAI;AAAA;AAEN,2BAAiB,KAAK;AAAA;AAAA;AAG1B,eAAS,CAAC,KAAK,IAAI,KAAK,IAAI;AAG5B;AAAA;AAKJ,UAAQ,QAAQ;AAEhB,cAAY,CAAC,QAAgB,KAAK,EAAE,KAAK,KAAK,QAAQ,EAAE,KAAK;AAAA;",
  "names": []
}
