<!DOCTYPE html>
<html lang="en">
<head>
  <title>Brains@Play Platform</title>
  <meta charset="UTF-8" />
  <link rel="icon" href="./favicon.ico" />
  <link rel="shortcut icon" href="./favicon.ico" />
  <link rel="apple-touch-icon" href="./logo192.png" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="theme-color" content="#000000" />
  <link rel="manifest" href="./manifest.webmanifest" />
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Montserrat" />
  <link href="./_dist_/styles/css/global.css" rel="stylesheet">
</head>
<body>
  <div class="loader">
    <div class="loader-mask"></div>
    <div class="loader-content">
        <img src="./_dist_/assets/logo_and_sub(v3).png">
    </div>
  </div>

<script type="module" src="./_dist_/index.js"></script>
<script>
 
  // https://developers.google.com/web/tools/workbox/modules/workbox-cli
  // it is needed because parcel will not recognize this as a file and not precess in its manner
  const sw = "./service-worker.js";

  navigator.serviceWorker
    .register(sw)
    .then(registration => {
      registration.onupdatefound = () => {
        const installingWorker = registration.installing;
        if (installingWorker == null) {
          return;
        }
        installingWorker.onstatechange = () => {
          if (installingWorker.state === "installed") {
            if (navigator.serviceWorker.controller) {
              alert("Update available! Refresh the page for new content!");
              console.log(
                "New content is available and will be used when all " +
                  "tabs for this page are closed. See https://bit.ly/CRA-PWA."
              );
            } else {
              console.log("Content is cached for offline use.");
            }
          }
        };
      };
    })
    .catch(error => {
      console.error("Error during service worker registration:", error);
    });

    </script>

<script>
//wakelock

let wakeLock = null;

const requestWakeLock = async () => {
    try {
        wakeLock = await navigator.wakeLock.request('screen');
        wakeLock.addEventListener('release', () => {
            console.log("Wake Lock released!");
        });
        console.log("Keeping awake...");
    }
    catch (err) {
        console.error(err.name,err.message);
    }
}

const releaseWakeLock = async () => {
    if(!wakeLock) {
        return;
    }
    try {
        await wakeLock.release();
        wakeLock = null;
    }
    catch (err){
        console.error(err.name,err.message);
    }
}

window.addEventListener('focus', () => {
    requestWakeLock();
});

window.addEventListener('blur', () => {
    releaseWakeLock();
});

</script>

<script>

//window.workers = new WorkerUtil(2,'./js/utils/eegworker.js',receivedMsg); // ???
//console.log(window.workers);
window.workerResponses=[]; //array of onmessage functions for the return trip data from webworkers
window.workers = [];
window.workerThreads = 2; //Make multiple workers for big tasks
window.workerThreadrot = 0;
//WebWorker only works when hosted (e.g. with node)
let workerURL = './_dist_/library/src/algorithms/eeg.worker.js';

try {
  window.workers = [];
    for(var i = 0; i < window.workerThreads; i++){
      window.workers.push(new Worker(workerURL,
        {name:'eegworker_'+window.workers.length, type: 'module'}));
        window.workers[i].onmessage = (e) => {
            var msg = e.data;
            //console.log(msg)
            //window.receivedMsg(msg);
            window.workerResponses.forEach((foo,i) => {
                foo(msg);
            });
        };
    }
    console.log("worker threads: ", window.workers.length)
}
catch (err) {
    console.error(err);
}

window.addWorker = (workerurl=workerURL) => {
    try {
      window.workers.push(new Worker(workerURL,
        {
        name:'eegworker_'+window.workers.length, 
        type: 'module',
        }));
        workers[i].onmessage = (e) => {
            var msg = e.data;
            //console.log(msg)
            //window.receivedMsg(msg);
            window.workerResponses.forEach((foo,i) => {
            foo(msg);
            })
        };
        console.log("worker threads: ", window.workers.length)
        return window.workers.length-1; //index
    } catch (err) {
        console.log(err);
    }
}

//input = {foo:'',data:[],origin:''}
//foo options: "xcor, autocor, cov1d, cov2d, sma, dft, multidft, multibandpassdft"
window.postToWorker = (input,workeridx = null) => {
    if(workeridx === null) {
      window.workers[window.workerThreadrot].postMessage(input);
        if(window.workerThreads > 1){
          window.workerThreadrot++;
            if(window.workerThreadrot >= window.workerThreads){
              window.workerThreadrot = 0;
            }
        }
    }
    else{
      window.workers[workeridx].postMessage(input);
    }
}

</script>

</body>
</html>
